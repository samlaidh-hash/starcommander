<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Star Sea - Weapon Arc Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #fff;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }
        .sidebar {
            width: 300px;
            background: #2a2a2a;
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #444;
        }
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            height: 100vh;
        }
        canvas {
            border: 2px solid #444;
            background: #0a0a0a;
            cursor: crosshair;
            display: block;
            width: 100%;
            height: 100%;
            flex: 1;
        }
        h1 {
            font-size: 18px;
            margin-bottom: 20px;
            color: #0ff;
        }
        h2 {
            font-size: 14px;
            margin: 15px 0 10px 0;
            color: #0ff;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #aaa;
        }
        select, input, button {
            width: 100%;
            padding: 8px;
            background: #333;
            border: 1px solid #555;
            color: #fff;
            font-size: 12px;
            border-radius: 4px;
        }
        select:focus, input:focus {
            outline: none;
            border-color: #0ff;
        }
        button {
            background: #0a5;
            border: none;
            cursor: pointer;
            margin-top: 5px;
            font-weight: bold;
        }
        button:hover {
            background: #0c7;
        }
        button.danger {
            background: #a00;
        }
        button.danger:hover {
            background: #c00;
        }
        button.secondary {
            background: #555;
        }
        button.secondary:hover {
            background: #777;
        }
        .weapon-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #555;
            padding: 5px;
            background: #222;
        }
        .weapon-item {
            padding: 5px;
            margin: 3px 0;
            background: #333;
            cursor: pointer;
            border-left: 3px solid #0ff;
        }
        .weapon-item:hover {
            background: #444;
        }
        .weapon-item.selected {
            background: #0a5;
            border-left-color: #0ff;
        }
        .info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            padding: 10px;
            border: 1px solid #555;
            font-size: 11px;
            max-width: 250px;
        }
        .status {
            margin-top: 10px;
            padding: 5px;
            background: #333;
            font-size: 11px;
            border-radius: 3px;
        }
        .mode-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        .mode-indicator.idle { background: #555; }
        .mode-indicator.arc-endpoint { background: #0ff; }
        .mode-indicator.arc-shape { background: #ff0; }
        .mode-indicator.arc-manual { background: #0f0; }
    </style>
</head>
<body>
    <div class="sidebar">
        <h1>Weapon Arc Editor</h1>
        
        <div class="control-group">
            <label>Faction:</label>
            <select id="faction-select">
                <option value="FEDERATION">Federation</option>
                <option value="TRIGON">Trigon</option>
                <option value="SCINTILIAN">Scintilian</option>
                <option value="DHOJAN">Dhojan</option>
                <option value="COMMONWEALTH">Commonwealth</option>
                <option value="ANDROMEDAN">Andromedan</option>
                <option value="PIRATE">Pirate</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Ship Class:</label>
            <select id="class-select">
                <option value="DD">Destroyer (DD)</option>
                <option value="CL">Light Cruiser (CL)</option>
                <option value="CA">Heavy Cruiser (CA)</option>
                <option value="BC">Battle Cruiser (BC)</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Weapon Type:</label>
            <select id="weapon-type-select">
                <option value="continuousBeam">Continuous Beam</option>
                <option value="heavyBeam">Heavy Beam</option>
                <option value="beam">Beam Weapon</option>
                <option value="pulseBeam">Pulse Beam</option>
                <option value="torpedo">Torpedo</option>
                <option value="dualTorpedo">Dual Torpedo</option>
                <option value="plasma">Plasma Torpedo</option>
                <option value="disruptor">Disruptor</option>
                <option value="streakBeam">Streak Beam</option>
                <!-- Commonwealth weapons -->
                <option value="quantumTorpedo">Quantum Torpedo</option>
                <!-- Dhojan weapons -->
                <option value="gravityTorpedo">Gravity Torpedo</option>
                <option value="gravBeam">Grav Beam</option>
                <!-- Andromedan weapons -->
                <option value="energyTorpedo">Energy Torpedo</option>
                <option value="tractorRepulsorBeam">Tractor-Repulsor Beam</option>
                <option value="randomLight">Random Light Weapon</option>
                <option value="randomHeavy">Random Heavy Weapon</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Arc Mode:</label>
            <select id="arc-mode-select">
                <option value="federation-arc">Federation: 2-Point Arc (Auto)</option>
                <option value="manual">Manual Arc Entry</option>
            </select>
        </div>
        
        <h2>Weapons</h2>
        <div class="weapon-list" id="weapon-list"></div>
        
        <div class="control-group">
            <button id="add-weapon-btn">Add Weapon</button>
            <button id="remove-weapon-btn" class="danger">Remove Selected</button>
        </div>
        
        <div class="control-group">
            <label>Arc (degrees):</label>
            <input type="number" id="arc-input" value="270" min="0" max="360">
        </div>
        
        <div class="control-group">
            <label>Arc Center (degrees):</label>
            <input type="number" id="arc-center-input" value="0" min="0" max="360">
        </div>
        
        <div class="control-group">
            <label>Weapon Name:</label>
            <input type="text" id="weapon-name-input" placeholder="Enter weapon name">
        </div>
        
        <div class="control-group" id="ready-mag-group" style="display: none;">
            <label>Ready Magazine Size:</label>
            <input type="number" id="ready-mag-input" value="0" min="0" max="20" step="1">
            <div style="font-size: 11px; color: #888; margin-top: 3px;">
                Number of torpedoes ready to fire (shown as dots above firing point)
            </div>
        </div>
        
        <div class="control-group" id="beam-array-group" style="display: none;">
            <label>Beam Array Extension:</label>
            <input type="number" id="beam-array-input" value="50" min="10" max="200" step="5">
            <div style="font-size: 11px; color: #888; margin-top: 3px;">
                Distance beam array extends (rear: perpendicular to centerline, fore: elliptical arc width)
            </div>
        </div>
        
        <div class="control-group">
            <label>Ship Scale Factor:</label>
            <input type="number" id="scale-factor-input" value="1.0" min="0.1" max="5.0" step="0.1">
            <div style="font-size: 11px; color: #888; margin-top: 3px;">
                Adjusts ship size relative to weapon positions (overrides auto-scaling)
            </div>
        </div>
        
        <div class="control-group">
            <button id="update-weapon-btn" class="secondary">Update Selected Weapon</button>
        </div>
        
        <h2>Canvas Controls</h2>
        <div class="control-group">
            <label>Zoom:</label>
            <input type="range" id="zoom-slider" min="0.25" max="4" step="0.1" value="1.0">
            <span id="zoom-value">100%</span>
            <button id="zoom-reset-btn" class="secondary">Reset Zoom</button>
        </div>
        <div class="control-group">
            <div style="font-size: 11px; color: #888;">
                <strong>Controls:</strong><br>
                • Mouse wheel: Zoom in/out<br>
                • Arrow keys: Move selected weapon (1px)<br>
                • Shift+Arrow: Move selected weapon (10px)<br>
                • Right-click drag: Pan canvas
            </div>
        </div>
        
        <div class="control-group">
            <button id="load-image-btn" class="secondary">Load Custom Image (PNG)</button>
            <button id="clear-image-btn" class="secondary">Clear Image</button>
            <div style="font-size: 11px; color: #888; margin-top: 5px;">
                Images auto-load when faction/class changes
            </div>
        </div>
        
        <div class="control-group">
            <button id="export-btn">Export JSON</button>
            <button id="import-btn" class="secondary">Import JSON</button>
        </div>
        
        <div class="status" id="status">Ready</div>
    </div>
    
    <div class="main-content">
        <canvas id="canvas"></canvas>
        <div class="info-panel">
            <div><strong>Mode:</strong> <span id="mode-text">Idle</span></div>
            <div id="instructions">Select faction and class, then add weapons. Click and drag weapons to move them.</div>
        </div>
    </div>
    
    <input type="file" id="file-input" style="display: none;" accept=".json">
    <input type="file" id="image-input" style="display: none;" accept=".png,.jpg,.jpeg,.gif">
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const factionSelect = document.getElementById('faction-select');
        const classSelect = document.getElementById('class-select');
        const weaponTypeSelect = document.getElementById('weapon-type-select');
        const arcModeSelect = document.getElementById('arc-mode-select');
        const weaponList = document.getElementById('weapon-list');
        const addWeaponBtn = document.getElementById('add-weapon-btn');
        const removeWeaponBtn = document.getElementById('remove-weapon-btn');
        const updateWeaponBtn = document.getElementById('update-weapon-btn');
        const exportBtn = document.getElementById('export-btn');
        const importBtn = document.getElementById('import-btn');
        const loadImageBtn = document.getElementById('load-image-btn');
        const clearImageBtn = document.getElementById('clear-image-btn');
        const arcInput = document.getElementById('arc-input');
        const arcCenterInput = document.getElementById('arc-center-input');
        const weaponNameInput = document.getElementById('weapon-name-input');
        const readyMagInput = document.getElementById('ready-mag-input');
        const readyMagGroup = document.getElementById('ready-mag-group');
        const beamArrayInput = document.getElementById('beam-array-input');
        const beamArrayGroup = document.getElementById('beam-array-group');
        const scaleFactorInput = document.getElementById('scale-factor-input');
        const zoomSlider = document.getElementById('zoom-slider');
        const zoomValue = document.getElementById('zoom-value');
        const zoomResetBtn = document.getElementById('zoom-reset-btn');
        const status = document.getElementById('status');
        const modeText = document.getElementById('mode-text');
        const instructions = document.getElementById('instructions');
        const fileInput = document.getElementById('file-input');
        const imageInput = document.getElementById('image-input');
        
        // Ship image state
        let shipImage = null;
        let imageScale = 1.0;
        let imageOffset = { x: 0, y: 0 };
        let manualScaleFactor = 1.0; // Manual scaling factor (overrides auto-scaling)
        // Default CA reference length based on fallback ship drawing (from y-40 to y+30 = 70px)
        // This represents the Federation CA fallback drawing size
        let caReferenceLength = 70; // Fallback Federation CA ship drawing length
        
        // State
        let weapons = [];
        let selectedWeaponIndex = -1;
        let mode = 'idle'; // 'idle', 'arc-endpoint', 'arc-shape', 'arc-manual'
        let arcPoints = []; // For Federation arc creation: [point1, point2, shapePoint]
        let hoveredPoint = null;
        
        // Drag state for moving weapons
        let isDragging = false;
        let dragWeaponIndex = -1;
        let dragOffset = { x: 0, y: 0 };
        
        // Zoom and pan state
        let zoomLevel = 1.0;
        let panOffset = { x: 0, y: 0 };
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        
        // Arrow key movement state
        let arrowKeyMoveAmount = 1; // Pixels per keypress
        
        // Ship center and scale (will be updated in resizeCanvas)
        let shipCenter = { x: 0, y: 0 };
        const shipScale = 1.0;
        
        // Canvas setup
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            // Update ship center when canvas resizes
            shipCenter = { x: canvas.width / 2, y: canvas.height / 2 };
            draw();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Weapon positions (from Ship.js)
        const WEAPON_POSITIONS = {
            forwardCenter: { x: 0, y: -30 },
            forwardPort: { x: -6, y: -14 },
            forwardStarboard: { x: 6, y: -14 },
            aftCenter: { x: 0, y: 70 },
            forwardTorpPort: { x: -3, y: -12 },
            forwardTorpStarboard: { x: 3, y: -12 },
            dualTorpCenter: { x: 0, y: -10 },
            aftTorpPort: { x: -3, y: 12 },
            aftTorpStarboard: { x: 3, y: 12 },
            disruptorPort: { x: -7, y: -13 },
            disruptorStarboard: { x: 7, y: -13 }
        };
        
        // Get size multiplier based on ship class (CA is baseline = 1.0)
        function getClassSizeMultiplier(shipClass) {
            switch (shipClass.toUpperCase()) {
                case 'DD': return 0.5;   // 50% smaller
                case 'CL': return 0.75;  // 25% smaller
                case 'CA': return 1.0;   // Baseline (current size)
                case 'BC': return 1.25;  // 25% bigger
                case 'BC': return 1.25;  // 25% bigger
                default: return 1.0;
            }
        }
        
        // Measure actual image length (excluding transparent pixels)
        function measureImageLength(img) {
            try {
                // Create a temporary canvas to analyze the image
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = img.width;
                tempCanvas.height = img.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(img, 0, 0);
                
                // Try to get image data (may fail due to CORS)
                let imageData;
                try {
                    imageData = tempCtx.getImageData(0, 0, img.width, img.height);
                } catch (e) {
                    // CORS error - fall back to using image dimensions
                    console.warn('Cannot read image data (CORS restriction), using image dimensions as fallback');
                    return Math.max(img.width, img.height);
                }
                
                const data = imageData.data;
                
                // Find bounding box of non-transparent pixels
                let minX = img.width, minY = img.height, maxX = 0, maxY = 0;
                let hasContent = false;
                
                for (let y = 0; y < img.height; y++) {
                    for (let x = 0; x < img.width; x++) {
                        const idx = (y * img.width + x) * 4;
                        const alpha = data[idx + 3];
                        
                        if (alpha > 0) { // Non-transparent pixel
                            hasContent = true;
                            minX = Math.min(minX, x);
                            minY = Math.min(minY, y);
                            maxX = Math.max(maxX, x);
                            maxY = Math.max(maxY, y);
                        }
                    }
                }
                
                if (!hasContent) {
                    // If no content found, use full image dimensions
                    return Math.max(img.width, img.height);
                }
                
                // Calculate length (use the longer dimension)
                const width = maxX - minX + 1;
                const height = maxY - minY + 1;
                return Math.max(width, height);
            } catch (e) {
                // Fallback: use image dimensions if measurement fails
                console.warn('Error measuring image length, using image dimensions:', e.message);
                return Math.max(img.width, img.height);
            }
        }
        
        // Calculate scale to fit canvas and apply class-based sizing
        function calculateImageScale(img, shipClass) {
            // Measure actual ship length (excluding transparent pixels)
            const actualLength = measureImageLength(img);
            
            // If this is CA, update the reference length (but keep default if it's the fallback)
            if (shipClass.toUpperCase() === 'CA' && actualLength > 0) {
                caReferenceLength = actualLength;
            }
            
            // Get desired size multiplier for this class
            const classMultiplier = getClassSizeMultiplier(shipClass);
            
            // Calculate target length based on CA reference (always use the stored reference)
            const targetLength = caReferenceLength * classMultiplier;
            
            // Calculate scale factor to achieve target length
            const scale = actualLength > 0 ? targetLength / actualLength : 1.0;
            
            return scale;
        }
        
        // Auto-load ship image based on faction and class
        function loadShipImage(faction, shipClass) {
            // Convert faction to lowercase for filename
            const factionLower = faction.toLowerCase();
            const classLower = shipClass.toLowerCase();
            
            // Try to find image file matching pattern: faction class *.png
            // First try exact pattern, then try with variations
            const imagePaths = [
                `ASSETS/IMAGES/${factionLower} ${classLower}.png`,
                `ASSETS/IMAGES/${factionLower} ${classLower} *.png`, // Will need to search
            ];
            
            // Try to load image - we'll try common patterns
            // Since we can't list directory, try common ship names or just the base pattern
            const basePath = `ASSETS/IMAGES/${factionLower} ${classLower}`;
            
            // Get class-based size multiplier
            const classMultiplier = getClassSizeMultiplier(shipClass);
            
            // Try loading with common ship name patterns
            const commonNames = {
                'federation': { 'dd': 'delta', 'cl': 'star', 'ca': 'nebula', 'bc': 'galaxy' },
                'trigon': { 'dd': 'sleet', 'cl': 'hail', 'ca': 'lightning', 'bc': 'thunder' },
                'scintilian': { 'dd': 'falcon', 'cl': 'hawk', 'ca': 'eagle', 'bc': 'condor' },
                'pirate': { 'dd': 'highwayman', 'cl': 'bandit', 'ca': 'reaver', 'bc': 'marauder' },
                'commonwealth': { 'dd': 'county', 'cl': 'barony', 'ca': 'duchy', 'bc': 'monarch' },
                'andromedan': { 'dd': 'hoplite', 'cl': 'warrior', 'ca': 'major', 'bc': 'knight' },
                'dhojan': { 'dd': 'lieutenant', 'cl': 'captain', 'ca': 'major', 'bc': 'general' }
            };
            
            const shipName = commonNames[factionLower] && commonNames[factionLower][classLower];
            const imagePath = shipName ? `${basePath} ${shipName}.png` : `${basePath}.png`;
            
            console.log(`Attempting to load image: ${imagePath}`);
            
            const img = new Image();
            // Don't set crossOrigin for local files - it can cause CORS issues
            
            img.onload = () => {
                console.log(`Image loaded successfully: ${imagePath}`);
                shipImage = img;
                // Calculate scale based on actual image length and class size requirements
                imageScale = calculateImageScale(img, shipClass);
                imageOffset = { x: 0, y: 0 };
                draw();
                const actualLength = measureImageLength(img);
                const displayName = shipName ? ` (${shipName})` : '';
                status.textContent = `Auto-loaded: ${faction} ${shipClass}${displayName} - Length: ${actualLength}px, Scale: ${(imageScale * 100).toFixed(1)}%`;
            };
            
            img.onerror = (e) => {
                // Image failed to load
                console.error('Image load error:', imagePath, e);
                shipImage = null;
                draw();
                status.textContent = `Failed to load: ${imagePath} - Using fallback drawing`;
            };
            
            // Try to load the image
            img.src = imagePath;
        }
        
        // Try to load JSON file for selected faction/class
        async function tryLoadJSON(faction, shipClass) {
            const filename = `${faction}_${shipClass}_weapons.json`;
            try {
                const response = await fetch(filename);
                if (response.ok) {
                    const data = await response.json();
                    // Verify it matches the current faction/class
                    if (data.faction === faction && data.shipClass === shipClass) {
                        return data;
                    }
                }
            } catch (error) {
                // File doesn't exist or other error - this is expected, not a problem
                // console.log(`No JSON file found: ${filename}`);
            }
            return null;
        }
        
        // Get random light weapon type (continuousBeam, streakBeam, or pulseBeam)
        function getRandomLightWeaponType() {
            const lightWeapons = ['continuousBeam', 'streakBeam', 'pulseBeam'];
            return lightWeapons[Math.floor(Math.random() * lightWeapons.length)];
        }
        
        // Get random heavy weapon type (torpedo, disruptor, or plasma)
        function getRandomHeavyWeaponType() {
            const heavyWeapons = ['torpedo', 'disruptor', 'plasma'];
            return heavyWeapons[Math.floor(Math.random() * heavyWeapons.length)];
        }
        
        // Get ready magazine size for torpedoes based on ship class
        function getTorpedoReadyMagSize(shipClass) {
            switch (shipClass.toUpperCase()) {
                case 'DD': return 2;
                case 'CL': return 3;
                case 'CA': return 4;
                case 'BC':
                case 'BB': return 5;
                default: return 3;
            }
        }
        
        // Load default weapons for selected faction/class
        async function loadDefaultWeapons() {
            const faction = factionSelect.value;
            const shipClass = classSelect.value;
            
            // Auto-load ship image
            loadShipImage(faction, shipClass);
            
            // Try to load JSON file first
            const jsonData = await tryLoadJSON(faction, shipClass);
            if (jsonData) {
                // Load from JSON
                if (jsonData.scaleFactor !== undefined) {
                    manualScaleFactor = parseFloat(jsonData.scaleFactor) || 1.0;
                    loadScaleFactor();
                }
                if (jsonData.weapons) {
                    weapons = jsonData.weapons;
                    selectedWeaponIndex = -1;
                    updateWeaponList();
                    draw();
                    status.textContent = `Loaded from ${faction}_${shipClass}_weapons.json`;
                    return;
                }
            }
            
            // Default weapons from Ship.js
            const defaults = {
                FEDERATION: {
                    DD: [
                        { type: 'continuousBeam', name: 'Forward Beam Battery', arc: 270, arcCenter: 0, position: WEAPON_POSITIONS.forwardCenter },
                        { type: 'dualTorpedo', name: 'Dual Torpedo Launcher', arc: 90, arcCenter: 0, arcCenters: [0, 180], position: WEAPON_POSITIONS.dualTorpCenter }
                    ],
                    CL: [
                        { type: 'continuousBeam', name: 'Forward Beam Battery', arc: 270, arcCenter: 0, position: WEAPON_POSITIONS.forwardCenter },
                        { type: 'dualTorpedo', name: 'Dual Torpedo Launcher', arc: 90, arcCenter: 0, arcCenters: [0, 180], position: WEAPON_POSITIONS.dualTorpCenter }
                    ],
                    CA: [
                        { type: 'continuousBeam', name: 'Forward Beam Battery', arc: 270, arcCenter: 0, position: WEAPON_POSITIONS.forwardCenter },
                        { type: 'continuousBeam', name: 'Aft Beam Battery', arc: 270, arcCenter: 180, position: WEAPON_POSITIONS.aftCenter },
                        { type: 'dualTorpedo', name: 'Dual Torpedo Launcher', arc: 90, arcCenter: 0, arcCenters: [0, 180], position: WEAPON_POSITIONS.dualTorpCenter }
                    ],
                    BC: [
                        { type: 'heavyBeam', name: 'Fore Heavy Beam Battery', arc: 270, arcCenter: 0, position: WEAPON_POSITIONS.forwardStarboard },
                        { type: 'continuousBeam', name: 'Aft Beam Array', arc: 270, arcCenter: 180, position: WEAPON_POSITIONS.aftCenter },
                        { type: 'dualTorpedo', name: 'Dual Torpedo Launcher', arc: 90, arcCenter: 0, arcCenters: [0, 180], position: WEAPON_POSITIONS.dualTorpCenter }
                    ]
                },
                TRIGON: {
                    DD: [
                        { type: 'disruptor', name: 'Port Wing Disruptor', arc: 120, arcCenter: 0, position: { x: -20, y: -10 } },
                        { type: 'disruptor', name: 'Starboard Wing Disruptor', arc: 120, arcCenter: 0, position: { x: 20, y: -10 } }
                    ],
                    CL: [
                        { type: 'disruptor', name: 'Port Wing Disruptor', arc: 120, arcCenter: 0, position: { x: -20, y: -10 } },
                        { type: 'disruptor', name: 'Starboard Wing Disruptor', arc: 120, arcCenter: 0, position: { x: 20, y: -10 } }
                    ],
                    CA: [
                        { type: 'disruptor', name: 'Nose Disruptor Cannon', arc: 120, arcCenter: 0, position: { x: 0, y: -30 } },
                        { type: 'disruptor', name: 'Port Wing Disruptor', arc: 120, arcCenter: 0, position: { x: -20, y: -10 } },
                        { type: 'disruptor', name: 'Starboard Wing Disruptor', arc: 120, arcCenter: 0, position: { x: 20, y: -10 } }
                    ],
                    BC: [
                        { type: 'disruptor', name: 'Nose Disruptor Cannon', arc: 120, arcCenter: 0, position: { x: 0, y: -30 } },
                        { type: 'disruptor', name: 'Port Wing Fwd Disruptor', arc: 120, arcCenter: 0, position: { x: -20, y: -10 } },
                        { type: 'disruptor', name: 'Starboard Wing Fwd Disruptor', arc: 120, arcCenter: 0, position: { x: 20, y: -10 } },
                        { type: 'disruptor', name: 'Port Wing Aft Disruptor', arc: 120, arcCenter: 180, position: { x: -20, y: 30 } },
                        { type: 'disruptor', name: 'Starboard Wing Aft Disruptor', arc: 120, arcCenter: 180, position: { x: 20, y: 30 } }
                    ]
                }
            };
            
            weapons = (defaults[faction] && defaults[faction][shipClass]) ? 
                defaults[faction][shipClass].map(w => ({ ...w })) : [];
            selectedWeaponIndex = -1;
            updateWeaponList();
            draw();
            status.textContent = `Loaded default weapons for ${faction} ${shipClass}`;
        }
        
        // Update weapon list display
        function updateWeaponList() {
            weaponList.innerHTML = '';
            weapons.forEach((weapon, index) => {
                const item = document.createElement('div');
                item.className = 'weapon-item' + (index === selectedWeaponIndex ? ' selected' : '');
                item.textContent = `${weapon.name || 'Unnamed'} (${weapon.type}) - Arc: ${weapon.arc}°, Center: ${weapon.arcCenter}°`;
                item.onclick = () => {
                    selectedWeaponIndex = index;
                    updateWeaponList();
                    loadWeaponToForm(weapon);
                    draw();
                };
                weaponList.appendChild(item);
            });
        }
        
        // Load weapon data to form
        function loadWeaponToForm(weapon) {
            weaponTypeSelect.value = weapon.type;
            arcInput.value = weapon.arc || 270;
            // For dual torpedo launchers, use first arc center if arcCenters array exists
            if (weapon.arcCenters && weapon.arcCenters.length > 0) {
                arcCenterInput.value = weapon.arcCenters[0] || 0;
            } else {
                arcCenterInput.value = weapon.arcCenter || 0;
            }
            weaponNameInput.value = weapon.name || '';
            
            // Show/hide ready magazine input based on weapon type
            const isTorpedo = (weapon.type === 'torpedo' || weapon.type === 'dualTorpedo' || weapon.type === 'quantumTorpedo' || weapon.type === 'gravityTorpedo' || weapon.type === 'energyTorpedo') && weapon.type !== 'plasma';
            if (isTorpedo) {
                readyMagGroup.style.display = 'block';
                readyMagInput.value = weapon.readyMagSize || weapon.loaded || 0;
            } else {
                readyMagGroup.style.display = 'none';
            }
            
            // Show/hide beam array extension input for beam weapons
            const isBeam = weapon.type === 'continuousBeam' || weapon.type === 'heavyBeam' || weapon.type === 'gravBeam' || weapon.type === 'tractorRepulsorBeam';
            if (isBeam) {
                beamArrayGroup.style.display = 'block';
                beamArrayInput.value = weapon.beamArrayExtension || weapon.arrayExtension || 50;
            } else {
                beamArrayGroup.style.display = 'none';
            }
        }
        
        // Update ready magazine and beam array visibility when weapon type changes
        weaponTypeSelect.addEventListener('change', () => {
            const isTorpedo = (weaponTypeSelect.value === 'torpedo' || weaponTypeSelect.value === 'dualTorpedo' || weaponTypeSelect.value === 'quantumTorpedo' || weaponTypeSelect.value === 'gravityTorpedo' || weaponTypeSelect.value === 'energyTorpedo') && weaponTypeSelect.value !== 'plasma';
            const isBeam = weaponTypeSelect.value === 'continuousBeam' || weaponTypeSelect.value === 'heavyBeam' || weaponTypeSelect.value === 'gravBeam' || weaponTypeSelect.value === 'tractorRepulsorBeam';
            readyMagGroup.style.display = isTorpedo ? 'block' : 'none';
            beamArrayGroup.style.display = isBeam ? 'block' : 'none';
        });
        
        // Load ship scale factor (global, not per-weapon)
        function loadScaleFactor() {
            scaleFactorInput.value = manualScaleFactor.toFixed(1);
        }
        
        // Convert screen coordinates to world coordinates (accounting for zoom/pan)
        function screenToWorld(screenX, screenY) {
            return {
                x: (screenX - panOffset.x - canvas.width / 2) / zoomLevel + shipCenter.x,
                y: (screenY - panOffset.y - canvas.height / 2) / zoomLevel + shipCenter.y
            };
        }
        
        // Convert world coordinates to screen coordinates
        function worldToScreen(worldX, worldY) {
            return {
                x: (worldX - shipCenter.x) * zoomLevel + canvas.width / 2 + panOffset.x,
                y: (worldY - shipCenter.y) * zoomLevel + canvas.height / 2 + panOffset.y
            };
        }
        
        // Draw everything
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Apply zoom and pan transforms
            ctx.save();
            ctx.translate(canvas.width / 2 + panOffset.x, canvas.height / 2 + panOffset.y);
            ctx.scale(zoomLevel, zoomLevel);
            ctx.translate(-shipCenter.x, -shipCenter.y);
            
            // Draw grid
            drawGrid();
            
            // Draw ship outline (simple representation)
            drawShipOutline();
            
            // Draw weapons and arcs
            weapons.forEach((weapon, index) => {
                const isSelected = index === selectedWeaponIndex;
                drawWeapon(weapon, isSelected);
            });
            
            // Draw Federation arc creation points
            if (mode === 'arc-endpoint' || mode === 'arc-shape') {
                arcPoints.forEach((point, i) => {
                    ctx.fillStyle = i < 2 ? '#0ff' : '#ff0';
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 5 / zoomLevel, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2 / zoomLevel;
                    ctx.stroke();
                });
                
                // Draw preview arc if we have 2 points
                if (arcPoints.length === 2) {
                    drawArcPreview(arcPoints[0], arcPoints[1], hoveredPoint);
                }
            }
            
            ctx.restore();
        }
        
        function drawGrid() {
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1 / zoomLevel;
            const gridSize = 50;
            const startX = Math.floor((shipCenter.x - canvas.width / zoomLevel / 2) / gridSize) * gridSize;
            const endX = Math.ceil((shipCenter.x + canvas.width / zoomLevel / 2) / gridSize) * gridSize;
            const startY = Math.floor((shipCenter.y - canvas.height / zoomLevel / 2) / gridSize) * gridSize;
            const endY = Math.ceil((shipCenter.y + canvas.height / zoomLevel / 2) / gridSize) * gridSize;
            
            for (let x = startX; x <= endX; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, startY);
                ctx.lineTo(x, endY);
                ctx.stroke();
            }
            for (let y = startY; y <= endY; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(startX, y);
                ctx.lineTo(endX, y);
                ctx.stroke();
            }
            
            // Center lines
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2 / zoomLevel;
            ctx.beginPath();
            ctx.moveTo(shipCenter.x, startY);
            ctx.lineTo(shipCenter.x, endY);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(startX, shipCenter.y);
            ctx.lineTo(endX, shipCenter.y);
            ctx.stroke();
        }
        
        function drawShipOutline() {
            // Draw loaded ship image if available
            if (shipImage) {
                // Apply manual scale factor (overrides auto-scaling)
                const finalScale = imageScale * manualScaleFactor;
                const imgWidth = shipImage.width * finalScale;
                const imgHeight = shipImage.height * finalScale;
                const imgX = shipCenter.x - imgWidth / 2 + imageOffset.x;
                const imgY = shipCenter.y - imgHeight / 2 + imageOffset.y;
                
                ctx.drawImage(shipImage, imgX, imgY, imgWidth, imgHeight);
            } else {
                // Fallback: Simple ship shape (pointing up)
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(shipCenter.x, shipCenter.y - 40);
                ctx.lineTo(shipCenter.x - 15, shipCenter.y + 20);
                ctx.lineTo(shipCenter.x, shipCenter.y + 30);
                ctx.lineTo(shipCenter.x + 15, shipCenter.y + 20);
                ctx.closePath();
                ctx.stroke();
            }
        }
        
        function drawWeapon(weapon, isSelected) {
            const pos = weapon.position || { x: 0, y: 0 };
            const worldPos = {
                x: shipCenter.x + pos.x,
                y: shipCenter.y + pos.y
            };
            
            // Check if this is a beam weapon (Federation beams use curved lines, not dots)
            const isBeam = weapon.type === 'continuousBeam' || weapon.type === 'heavyBeam' || weapon.type === 'gravBeam' || weapon.type === 'tractorRepulsorBeam';
            
            // Draw ready magazine dots for torpedo launchers (not plasma)
            const isTorpedo = (weapon.type === 'torpedo' || weapon.type === 'dualTorpedo' || weapon.type === 'quantumTorpedo' || weapon.type === 'gravityTorpedo' || weapon.type === 'energyTorpedo') && weapon.type !== 'plasma';
            if (isTorpedo && weapon.readyMagSize && weapon.readyMagSize > 0) {
                drawReadyMagazine(worldPos, weapon.readyMagSize, weapon.maxLoaded || weapon.readyMagSize);
            }
            
            if (isBeam) {
                // Draw curved beam array line for Federation beam weapons
                // Note: This is called within the zoom/pan transform context
                drawBeamArray(weapon, worldPos, isSelected);
            } else {
                // Draw point firing position for non-beam weapons (torpedoes, etc.)
                const radius = 4; // Keep constant size regardless of selection
                ctx.fillStyle = isSelected ? '#0ff' : '#0f0';
                ctx.beginPath();
                ctx.arc(worldPos.x, worldPos.y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw selection halo if selected
                if (isSelected) {
                    ctx.strokeStyle = '#0ff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(worldPos.x, worldPos.y, radius + 3, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
            
            // Draw arc
            drawWeaponArc(weapon, worldPos, isSelected);
        }
        
        // Draw beam array for Federation beam weapons
        // Rear beams: rounded rectangle perpendicular to centerline
        // Fore beams: elliptical 220-degree arc
        function drawBeamArray(weapon, center, isSelected) {
            const arcCenter = weapon.arcCenter || 0;
            const extension = weapon.beamArrayExtension || weapon.arrayExtension || 50;
            // Scale line width with extension (base width at extension 50)
            const baseLineWidth = isSelected ? 4 : 3;
            const lineWidth = baseLineWidth * (extension / 50);
            const cornerRadius = 8; // Rounded rectangle corner radius
            
            ctx.strokeStyle = isSelected ? '#0ff' : '#0f5';
            ctx.lineWidth = lineWidth;
            ctx.globalAlpha = isSelected ? 1.0 : 0.9;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // Determine if this is a rear beam (180 degrees) or fore beam (0 degrees)
            const isRear = Math.abs(arcCenter - 180) < 45; // Within 45 degrees of 180
            const isFore = Math.abs(arcCenter) < 45 || Math.abs(arcCenter - 360) < 45; // Within 45 degrees of 0
            
            if (isRear) {
                // Rear beam: Rounded rectangle perpendicular to centerline
                // Rectangle extends horizontally (perpendicular to ship centerline which is vertical)
                const halfWidth = extension / 2;
                const height = 12; // Fixed height for the rectangle
                
                ctx.beginPath();
                // Draw rounded rectangle
                ctx.moveTo(center.x - halfWidth + cornerRadius, center.y - height / 2);
                ctx.lineTo(center.x + halfWidth - cornerRadius, center.y - height / 2);
                ctx.arc(center.x + halfWidth - cornerRadius, center.y - height / 2 + cornerRadius, cornerRadius, -Math.PI / 2, 0);
                ctx.lineTo(center.x + halfWidth, center.y + height / 2 - cornerRadius);
                ctx.arc(center.x + halfWidth - cornerRadius, center.y + height / 2 - cornerRadius, cornerRadius, 0, Math.PI / 2);
                ctx.lineTo(center.x - halfWidth + cornerRadius, center.y + height / 2);
                ctx.arc(center.x - halfWidth + cornerRadius, center.y + height / 2 - cornerRadius, cornerRadius, Math.PI / 2, Math.PI);
                ctx.lineTo(center.x - halfWidth, center.y - height / 2 + cornerRadius);
                ctx.arc(center.x - halfWidth + cornerRadius, center.y - height / 2 + cornerRadius, cornerRadius, Math.PI, -Math.PI / 2);
                ctx.closePath();
                ctx.stroke();
                
            } else if (isFore) {
                // Fore beam: Elliptical 200-degree arc (100 degrees each side of centerline)
                // Ellipse stretches left to right (horizontally), centered on vertical centerline
                // Centerline is at 0 degrees (pointing up/vertical)
                const ellipseWidth = extension; // Horizontal radius (left-right, the major axis)
                const ellipseHeight = extension * 0.78; // Vertical radius (front-back, the minor axis) - increased by 30% (0.6 * 1.3 = 0.78)
                
                // Arc extends 100 degrees on each side of centerline (0 degrees = up)
                // The ellipse is oriented horizontally (left-right), so we need to draw it correctly
                // Game coordinates: 0 = up, 90 = right, 180 = down, 270 = left
                // Canvas coordinates: 0 = right, 90 = down, 180 = left, 270 = up
                // For fore beam (arcCenter = 0, pointing up), centerline is vertical
                // The ellipse should stretch horizontally (left-right) around the vertical centerline
                const halfArc = 100 * Math.PI / 180; // 100 degrees in radians
                
                // Draw elliptical arc using parametric equation
                // The ellipse major axis is horizontal (left-right)
                // Arc sweeps 100 degrees on each side of the vertical centerline
                ctx.beginPath();
                const numPoints = 60; // Number of points for smooth curve
                
                // Draw from -100° to +100° relative to vertical centerline, symmetric
                // In canvas coordinates, vertical (up) is at -90° (or 270°)
                const verticalCenterline = -Math.PI / 2; // -90° in radians (up in canvas)
                
                for (let i = 0; i <= numPoints; i++) {
                    // Parameter t goes from -halfArc to +halfArc (symmetric around 0)
                    // This is the angle relative to the vertical centerline
                    const t = -halfArc + (2 * halfArc) * (i / numPoints);
                    
                    // Calculate point on ellipse in local coordinates
                    // The ellipse is oriented horizontally: wider left-right, narrower front-back
                    // For an ellipse centered on vertical axis, we need to calculate points
                    // that form an arc from left (-100°) to right (+100°) relative to vertical
                    const angle = verticalCenterline + t; // Angle in canvas coordinates
                    
                    // Calculate point on ellipse at this angle
                    // For horizontal ellipse: x = width * cos(angle), y = height * sin(angle)
                    // But we need to account for the ellipse orientation
                    const localX = ellipseWidth * Math.cos(angle);
                    const localY = ellipseHeight * Math.sin(angle);
                    
                    const x = center.x + localX;
                    const y = center.y + localY;
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            } else {
                // Side or other orientation: Use circular arc as fallback
                const arrayRadius = extension / 2;
                const arc = weapon.arc || 270;
                const centerRad = (arcCenter - 90) * Math.PI / 180;
                const halfArc = (arc / 2) * Math.PI / 180;
                const startAngle = centerRad - halfArc;
                const endAngle = centerRad + halfArc;
                
                ctx.beginPath();
                ctx.arc(center.x, center.y, arrayRadius, startAngle, endAngle);
                ctx.stroke();
            }
            
            // Draw a center point to show the array position
            ctx.fillStyle = isSelected ? '#0ff' : '#0f5';
            ctx.beginPath();
            ctx.arc(center.x, center.y, 2, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.globalAlpha = 1.0;
        }
        
        // Draw ready magazine as colored dots above the weapon
        // Note: This is called within the zoom/pan transform context, so coordinates are in world space
        function drawReadyMagazine(worldPos, loaded, maxLoaded) {
            const dotSpacing = 4; // Space between dots
            const dotRadius = 2; // Dot radius
            const startX = worldPos.x - ((maxLoaded - 1) * dotSpacing) / 2;
            const dotY = worldPos.y - 15; // Above the weapon
            
            for (let i = 0; i < maxLoaded; i++) {
                const dotX = startX + i * dotSpacing;
                ctx.fillStyle = i < loaded ? '#0f0' : '#333'; // Green for loaded, dark gray for empty
                ctx.beginPath();
                ctx.arc(dotX, dotY, dotRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Check if a point is near a weapon position (screen coordinates)
        function getWeaponAtPoint(screenX, screenY) {
            const world = screenToWorld(screenX, screenY);
            const threshold = 10 / zoomLevel; // Scale threshold with zoom
            for (let i = 0; i < weapons.length; i++) {
                const weapon = weapons[i];
                const pos = weapon.position || { x: 0, y: 0 };
                const worldPos = {
                    x: shipCenter.x + pos.x,
                    y: shipCenter.y + pos.y
                };
                
                // For beam weapons, check distance to the curved array line
                if (weapon.type === 'continuousBeam' || weapon.type === 'heavyBeam') {
                    const arc = weapon.arc || 270;
                    const arcCenter = weapon.arcCenter || 0;
                    const arrayRadius = 40;
                    const centerRad = (arcCenter - 90) * Math.PI / 180;
                    const halfArc = (arc / 2) * Math.PI / 180;
                    const startAngle = centerRad - halfArc;
                    const endAngle = centerRad + halfArc;
                    
                    // Calculate distance from point to center
                    const dx = world.x - worldPos.x;
                    const dy = world.y - worldPos.y;
                    const distToCenter = Math.sqrt(dx * dx + dy * dy);
                    
                    // Check if point is near the arc (within threshold of the arc radius)
                    if (Math.abs(distToCenter - arrayRadius) <= threshold) {
                        // Check if angle is within the arc range
                        const angle = Math.atan2(dy, dx);
                        // Normalize angle to [0, 2π]
                        let normalizedAngle = angle;
                        if (normalizedAngle < 0) normalizedAngle += 2 * Math.PI;
                        
                        // Normalize start/end angles
                        let normStart = startAngle;
                        let normEnd = endAngle;
                        if (normStart < 0) normStart += 2 * Math.PI;
                        if (normEnd < 0) normEnd += 2 * Math.PI;
                        
                        // Check if angle is within arc (handle wrap-around)
                        const inArc = (normStart <= normEnd && normalizedAngle >= normStart && normalizedAngle <= normEnd) ||
                                     (normStart > normEnd && (normalizedAngle >= normStart || normalizedAngle <= normEnd));
                        
                        if (inArc) {
                            return i;
                        }
                    }
                } else {
                    // For point weapons, check distance to point
                    const distance = Math.sqrt((world.x - worldPos.x) ** 2 + (world.y - worldPos.y) ** 2);
                    if (distance <= threshold) {
                        return i;
                    }
                }
            }
            return -1;
        }
        
        // Move selected weapon with arrow keys
        function moveSelectedWeapon(deltaX, deltaY) {
            if (selectedWeaponIndex >= 0 && selectedWeaponIndex < weapons.length) {
                const weapon = weapons[selectedWeaponIndex];
                const pos = weapon.position || { x: 0, y: 0 };
                weapon.position = {
                    x: pos.x + deltaX,
                    y: pos.y + deltaY
                };
                updateWeaponList();
                draw();
                status.textContent = `Weapon moved: (${weapon.position.x.toFixed(1)}, ${weapon.position.y.toFixed(1)})`;
            }
        }
        
        function drawWeaponArc(weapon, center, isSelected) {
            const arc = weapon.arc || 270;
            const arcCenter = weapon.arcCenter || 0;
            const radius = 100;
            
            // Check if this is a beam weapon (Federation beams fire in arcs)
            const isBeam = weapon.type === 'continuousBeam' || weapon.type === 'heavyBeam' || weapon.type === 'gravBeam' || weapon.type === 'tractorRepulsorBeam';
            
            // Check if this is a dual torpedo launcher with dual arc centers
            const arcCenters = weapon.arcCenters || (weapon.type === 'dualTorpedo' ? [0, 180] : null);
            
            if (arcCenters && arcCenters.length > 1) {
                // Draw multiple arcs (fore and aft for dual torpedo launcher)
                arcCenters.forEach((arcCtr, index) => {
                    drawSingleArc(center, arc, arcCtr, radius, isSelected, isBeam);
                });
            } else {
                // Single arc (standard behavior)
                drawSingleArc(center, arc, arcCenter, radius, isSelected, isBeam);
            }
            
            ctx.globalAlpha = 1.0;
        }
        
        // Helper function to draw a single arc
        function drawSingleArc(center, arc, arcCenter, radius, isSelected, isBeam) {
            // Convert arcCenter to radians (0 = up, 90 = right, 180 = down, 270 = left)
            const centerRad = (arcCenter - 90) * Math.PI / 180;
            const halfArc = (arc / 2) * Math.PI / 180;
            const startAngle = centerRad - halfArc;
            const endAngle = centerRad + halfArc;
            
            // For beam weapons, draw filled arc area to show firing arc more prominently
            if (isBeam) {
                // Draw filled arc sector for beam weapons
                ctx.fillStyle = isSelected ? 'rgba(0, 255, 255, 0.15)' : 'rgba(0, 255, 100, 0.1)';
                ctx.beginPath();
                ctx.moveTo(center.x, center.y);
                ctx.arc(center.x, center.y, radius, startAngle, endAngle);
                ctx.closePath();
                ctx.fill();
            }
            
            // Draw arc outline
            ctx.strokeStyle = isSelected ? (isBeam ? '#0ff' : '#0ff') : (isBeam ? '#0f5' : '#0f5');
            ctx.lineWidth = isSelected ? 3 : 2;
            ctx.globalAlpha = isSelected ? 1.0 : (isBeam ? 0.8 : 0.6);
            
            ctx.beginPath();
            ctx.arc(center.x, center.y, radius, startAngle, endAngle);
            ctx.stroke();
            
            // Draw arc boundaries (lines from center to arc edges)
            ctx.strokeStyle = isSelected ? '#ff0' : (isBeam ? '#0fa' : '#f50');
            ctx.lineWidth = isSelected ? 2 : 1;
            ctx.beginPath();
            ctx.moveTo(center.x, center.y);
            ctx.lineTo(
                center.x + Math.cos(startAngle) * radius,
                center.y + Math.sin(startAngle) * radius
            );
            ctx.moveTo(center.x, center.y);
            ctx.lineTo(
                center.x + Math.cos(endAngle) * radius,
                center.y + Math.sin(endAngle) * radius
            );
            ctx.stroke();
        }
        
        function drawArcPreview(point1, point2, shapePoint) {
            if (!point1 || !point2) return;
            
            ctx.strokeStyle = '#ff0';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            
            if (shapePoint) {
                // Quadratic bezier curve
                ctx.beginPath();
                ctx.moveTo(point1.x, point1.y);
                ctx.quadraticCurveTo(shapePoint.x, shapePoint.y, point2.x, point2.y);
                ctx.stroke();
            } else {
                // Straight line preview
                ctx.beginPath();
                ctx.moveTo(point1.x, point1.y);
                ctx.lineTo(point2.x, point2.y);
                ctx.stroke();
            }
            
            ctx.setLineDash([]);
        }
        
        // Calculate arc from two endpoints and shape point (Federation mode)
        function calculateArcFromPoints(point1, point2, shapePoint) {
            if (!point1 || !point2) return null;
            
            // Calculate center point (midpoint of endpoints)
            const center = {
                x: (point1.x + point2.x) / 2,
                y: (point1.y + point2.y) / 2
            };
            
            // Calculate angles from center to endpoints
            const angle1 = Math.atan2(point1.y - center.y, point1.x - center.x) * 180 / Math.PI;
            const angle2 = Math.atan2(point2.y - center.y, point2.x - center.x) * 180 / Math.PI;
            
            // Calculate arc span
            let arcSpan = Math.abs(angle2 - angle1);
            if (arcSpan > 180) arcSpan = 360 - arcSpan;
            
            // Calculate arc center (average of angles, converted to game coordinates)
            let arcCenter = (angle1 + angle2) / 2;
            // Convert from canvas coordinates (0 = right) to game coordinates (0 = up)
            arcCenter = (arcCenter + 90) % 360;
            if (arcCenter < 0) arcCenter += 360;
            
            return {
                arc: arcSpan,
                arcCenter: arcCenter,
                position: {
                    x: center.x - shipCenter.x,
                    y: center.y - shipCenter.y
                }
            };
        }
        
        // Canvas mouse down handler (for dragging weapons)
        canvas.addEventListener('mousedown', (e) => {
            if (mode !== 'idle') return; // Don't interfere with arc creation mode
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check if clicking on a weapon position
            const weaponIndex = getWeaponAtPoint(x, y);
            if (weaponIndex >= 0) {
                isDragging = true;
                dragWeaponIndex = weaponIndex;
                selectedWeaponIndex = weaponIndex;
                const weapon = weapons[weaponIndex];
                const pos = weapon.position || { x: 0, y: 0 };
                const worldPos = {
                    x: shipCenter.x + pos.x,
                    y: shipCenter.y + pos.y
                };
                
                // For beam weapons, calculate drag offset from the nearest point on the array line
                if (weapon.type === 'continuousBeam' || weapon.type === 'heavyBeam') {
                    const arc = weapon.arc || 270;
                    const arcCenter = weapon.arcCenter || 0;
                    const arrayRadius = 40;
                    const centerRad = (arcCenter - 90) * Math.PI / 180;
                    const halfArc = (arc / 2) * Math.PI / 180;
                    const startAngle = centerRad - halfArc;
                    const endAngle = centerRad + halfArc;
                    
                    // Find nearest point on the arc to the click point
                    const world = screenToWorld(x, y);
                    const dx = world.x - worldPos.x;
                    const dy = world.y - worldPos.y;
                    const angle = Math.atan2(dy, dx);
                    
                    // Clamp angle to arc range
                    let clampedAngle = angle;
                    if (clampedAngle < startAngle) clampedAngle = startAngle;
                    if (clampedAngle > endAngle) clampedAngle = endAngle;
                    
                    // Calculate nearest point on arc
                    const nearestX = worldPos.x + Math.cos(clampedAngle) * arrayRadius;
                    const nearestY = worldPos.y + Math.sin(clampedAngle) * arrayRadius;
                    const nearestScreen = worldToScreen(nearestX, nearestY);
                    
                    dragOffset = {
                        x: x - nearestScreen.x,
                        y: y - nearestScreen.y
                    };
                } else {
                    // For point weapons, use center point
                    const screenPos = worldToScreen(worldPos.x, worldPos.y);
                    dragOffset = {
                        x: x - screenPos.x,
                        y: y - screenPos.y
                    };
                }
                
                updateWeaponList();
                loadWeaponToForm(weapon);
                draw();
            }
        });
        
        // Canvas mouse move handler (for dragging)
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const world = screenToWorld(x, y);
            
            if (isDragging && dragWeaponIndex >= 0) {
                // Update weapon position (convert screen to world coordinates)
                const world = screenToWorld(x - dragOffset.x, y - dragOffset.y);
                const weapon = weapons[dragWeaponIndex];
                weapon.position = {
                    x: world.x - shipCenter.x,
                    y: world.y - shipCenter.y
                };
                draw();
            } else if (mode === 'arc-shape' && arcPoints.length === 2) {
                // Existing arc shape preview
                hoveredPoint = { x: world.x, y: world.y };
                draw();
            } else if (mode === 'idle') {
                // Change cursor when hovering over a weapon
                const weaponIndex = getWeaponAtPoint(x, y);
                if (weaponIndex >= 0) {
                    const weapon = weapons[weaponIndex];
                    // Use 'grab' cursor for beam arrays, 'move' for point weapons
                    canvas.style.cursor = (weapon.type === 'continuousBeam' || weapon.type === 'heavyBeam') ? 'grab' : 'move';
                } else {
                    canvas.style.cursor = 'crosshair';
                }
            }
        });
        
        // Canvas mouse up handler (end dragging)
        canvas.addEventListener('mouseup', (e) => {
            if (isDragging) {
                isDragging = false;
                dragWeaponIndex = -1;
                canvas.style.cursor = 'crosshair';
                status.textContent = 'Weapon position updated';
            }
        });
        
        // Canvas mouse leave handler (cancel dragging if mouse leaves canvas)
        canvas.addEventListener('mouseleave', (e) => {
            if (isDragging) {
                isDragging = false;
                dragWeaponIndex = -1;
                canvas.style.cursor = 'crosshair';
            }
        });
        
        // Zoom slider handler
        zoomSlider.addEventListener('input', (e) => {
            zoomLevel = parseFloat(e.target.value);
            zoomValue.textContent = `${Math.round(zoomLevel * 100)}%`;
            draw();
        });
        
        // Zoom reset button
        zoomResetBtn.addEventListener('click', () => {
            zoomLevel = 1.0;
            panOffset = { x: 0, y: 0 };
            zoomSlider.value = 1.0;
            zoomValue.textContent = '100%';
            draw();
            status.textContent = 'Zoom and pan reset';
        });
        
        // Mouse wheel zoom
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Get world coordinates before zoom
            const worldBefore = screenToWorld(mouseX, mouseY);
            
            // Adjust zoom
            const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
            zoomLevel = Math.max(0.25, Math.min(4, zoomLevel * zoomDelta));
            zoomSlider.value = zoomLevel;
            zoomValue.textContent = `${Math.round(zoomLevel * 100)}%`;
            
            // Get world coordinates after zoom
            const worldAfter = screenToWorld(mouseX, mouseY);
            
            // Adjust pan to keep mouse point fixed
            panOffset.x += (worldBefore.x - worldAfter.x) * zoomLevel;
            panOffset.y += (worldBefore.y - worldAfter.y) * zoomLevel;
            
            draw();
        });
        
        // Right-click pan
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
        
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 2) { // Right mouse button
                isPanning = true;
                panStart = { x: e.clientX, y: e.clientY };
                canvas.style.cursor = 'grabbing';
            }
        });
        
        window.addEventListener('mousemove', (e) => {
            if (isPanning) {
                panOffset.x += e.clientX - panStart.x;
                panOffset.y += e.clientY - panStart.y;
                panStart = { x: e.clientX, y: e.clientY };
                draw();
            }
        });
        
        window.addEventListener('mouseup', (e) => {
            if (e.button === 2 && isPanning) {
                isPanning = false;
                canvas.style.cursor = 'crosshair';
            }
        });
        
        // Arrow key movement
        window.addEventListener('keydown', (e) => {
            if (selectedWeaponIndex >= 0 && mode === 'idle') {
                const moveAmount = e.shiftKey ? 10 : 1; // Shift = 10px, normal = 1px
                let moved = false;
                
                switch(e.key) {
                    case 'ArrowUp':
                        moveSelectedWeapon(0, -moveAmount);
                        moved = true;
                        break;
                    case 'ArrowDown':
                        moveSelectedWeapon(0, moveAmount);
                        moved = true;
                        break;
                    case 'ArrowLeft':
                        moveSelectedWeapon(-moveAmount, 0);
                        moved = true;
                        break;
                    case 'ArrowRight':
                        moveSelectedWeapon(moveAmount, 0);
                        moved = true;
                        break;
                }
                
                if (moved) {
                    e.preventDefault();
                }
            }
        });
        
        // Canvas click handler
        canvas.addEventListener('click', (e) => {
            // Don't process clicks if we just finished dragging
            if (isDragging) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const world = screenToWorld(x, y);
            
            if (mode === 'arc-endpoint') {
                arcPoints.push({ x: world.x, y: world.y });
                if (arcPoints.length === 2) {
                    mode = 'arc-shape';
                    updateMode('arc-shape');
                    instructions.textContent = 'Click a third point to shape the curve';
                } else {
                    instructions.textContent = 'Click second endpoint';
                }
                draw();
            } else if (mode === 'arc-shape') {
                arcPoints.push({ x: world.x, y: world.y });
                const arcData = calculateArcFromPoints(arcPoints[0], arcPoints[1], arcPoints[2]);
                if (arcData) {
                    const weapon = {
                        type: weaponTypeSelect.value,
                        name: weaponNameInput.value || `Weapon ${weapons.length + 1}`,
                        arc: Math.round(arcData.arc),
                        arcCenter: Math.round(arcData.arcCenter),
                        position: arcData.position
                    };
                    
                    // Add ready magazine size for torpedo launchers (not plasma)
                    const isTorpedo = (weapon.type === 'torpedo' || weapon.type === 'dualTorpedo' || weapon.type === 'quantumTorpedo' || weapon.type === 'gravityTorpedo' || weapon.type === 'energyTorpedo') && weapon.type !== 'plasma';
                    if (isTorpedo && readyMagInput.value) {
                        weapon.readyMagSize = parseInt(readyMagInput.value) || 0;
                        weapon.maxLoaded = weapon.readyMagSize;
                    }
                    
                    // Add beam array extension for beam weapons
                    const isBeam = weapon.type === 'continuousBeam' || weapon.type === 'heavyBeam' || weapon.type === 'gravBeam' || weapon.type === 'tractorRepulsorBeam';
                    if (isBeam && beamArrayInput.value) {
                        weapon.beamArrayExtension = parseInt(beamArrayInput.value) || 50;
                    }
                    
                    weapons.push(weapon);
                    selectedWeaponIndex = weapons.length - 1;
                    updateWeaponList();
                    loadWeaponToForm(weapon);
                    arcPoints = [];
                    mode = 'idle';
                    updateMode('idle');
                    instructions.textContent = 'Arc created! Select faction and class, then add weapons';
                    status.textContent = `Added ${weapon.name}`;
                }
                draw();
            }
        });
        
        // Note: mousemove handler moved above to handle both dragging and arc preview
        
        // Update mode display
        function updateMode(newMode) {
            mode = newMode;
            const modeNames = {
                'idle': 'Idle',
                'arc-endpoint': 'Creating Arc (Click 2 Endpoints)',
                'arc-shape': 'Shaping Arc (Click Shape Point)',
                'arc-manual': 'Manual Entry'
            };
            modeText.textContent = modeNames[newMode] || 'Unknown';
        }
        
        // Event handlers
        factionSelect.addEventListener('change', loadDefaultWeapons);
        classSelect.addEventListener('change', loadDefaultWeapons);
        
        addWeaponBtn.addEventListener('click', () => {
            const arcMode = arcModeSelect.value;
            if (arcMode === 'federation-arc' && factionSelect.value === 'FEDERATION') {
                mode = 'arc-endpoint';
                arcPoints = [];
                updateMode('arc-endpoint');
                instructions.textContent = 'Click first endpoint of arc';
                status.textContent = 'Click two points to create arc';
            } else {
                // Manual mode
                const weaponType = weaponTypeSelect.value; // Keep as randomLight/randomHeavy if selected
                
                const weapon = {
                    type: weaponType, // Store randomLight/randomHeavy as-is for game to resolve later
                    name: weaponNameInput.value || `Weapon ${weapons.length + 1}`,
                    arc: parseInt(arcInput.value) || 270,
                    arcCenter: parseInt(arcCenterInput.value) || 0,
                    position: { x: 0, y: -30 } // Default position
                };
                
                // For random heavy weapons, set ready magazine size based on class (for torpedoes)
                // This will be used if the random selection picks a torpedo
                if (weaponType === 'randomHeavy') {
                    weapon.readyMagSize = getTorpedoReadyMagSize(classSelect.value);
                    weapon.maxLoaded = weapon.readyMagSize;
                }
                
                // For non-random torpedo launchers (not plasma)
                const isTorpedo = (weapon.type === 'torpedo' || weapon.type === 'dualTorpedo' || weapon.type === 'quantumTorpedo' || weapon.type === 'gravityTorpedo' || weapon.type === 'energyTorpedo') && weapon.type !== 'plasma';
                if (isTorpedo) {
                    // Use ready mag input if provided, otherwise use class-based default
                    if (readyMagInput.value) {
                        weapon.readyMagSize = parseInt(readyMagInput.value) || 0;
                    } else {
                        weapon.readyMagSize = getTorpedoReadyMagSize(classSelect.value);
                    }
                    weapon.maxLoaded = weapon.readyMagSize;
                }
                
                // Add beam array extension for beam weapons (only for non-random types)
                const isBeam = weapon.type === 'continuousBeam' || weapon.type === 'heavyBeam' || weapon.type === 'gravBeam' || weapon.type === 'tractorRepulsorBeam';
                if (isBeam && beamArrayInput.value) {
                    weapon.beamArrayExtension = parseInt(beamArrayInput.value) || 50;
                }
                
                weapons.push(weapon);
                selectedWeaponIndex = weapons.length - 1;
                updateWeaponList();
                loadWeaponToForm(weapon);
                status.textContent = `Added ${weapon.name} (${weaponType})`;
            }
            draw();
        });
        
        removeWeaponBtn.addEventListener('click', () => {
            if (selectedWeaponIndex >= 0) {
                weapons.splice(selectedWeaponIndex, 1);
                selectedWeaponIndex = -1;
                updateWeaponList();
                draw();
                status.textContent = 'Weapon removed';
            }
        });
        
        updateWeaponBtn.addEventListener('click', () => {
            if (selectedWeaponIndex >= 0) {
                const weapon = weapons[selectedWeaponIndex];
                const weaponType = weaponTypeSelect.value; // Keep as randomLight/randomHeavy if selected
                
                weapon.type = weaponType; // Store randomLight/randomHeavy as-is for game to resolve later
                weapon.arc = parseInt(arcInput.value) || 270;
                weapon.arcCenter = parseInt(arcCenterInput.value) || 0;
                weapon.name = weaponNameInput.value || `Weapon ${selectedWeaponIndex + 1}`;
                
                // For random heavy weapons, set ready magazine size based on class (for torpedoes)
                if (weaponType === 'randomHeavy') {
                    weapon.readyMagSize = getTorpedoReadyMagSize(classSelect.value);
                    weapon.maxLoaded = weapon.readyMagSize;
                }
                
                // For dual torpedo launchers, set arcCenters to [0, 180] for fore and aft firing
                if (weapon.type === 'dualTorpedo') {
                    weapon.arcCenters = [0, 180]; // Fore (0°) and Aft (180°)
                } else {
                    delete weapon.arcCenters;
                }
                
                // Add ready magazine size for torpedo launchers (not plasma, not random)
                const isTorpedo = (weapon.type === 'torpedo' || weapon.type === 'dualTorpedo' || weapon.type === 'quantumTorpedo' || weapon.type === 'gravityTorpedo' || weapon.type === 'energyTorpedo') && weapon.type !== 'plasma';
                if (isTorpedo) {
                    // Use ready mag input if provided, otherwise use class-based default
                    if (readyMagInput.value) {
                        weapon.readyMagSize = parseInt(readyMagInput.value) || 0;
                    } else {
                        weapon.readyMagSize = getTorpedoReadyMagSize(classSelect.value);
                    }
                    weapon.maxLoaded = weapon.readyMagSize; // Set maxLoaded to match readyMagSize
                } else if (weaponType !== 'randomHeavy') {
                    // Only delete if not a random heavy (which needs it for torpedo possibility)
                    delete weapon.readyMagSize;
                    delete weapon.maxLoaded;
                }
                
                // Add beam array extension for beam weapons (only for non-random types)
                const isBeam = weapon.type === 'continuousBeam' || weapon.type === 'heavyBeam' || weapon.type === 'gravBeam' || weapon.type === 'tractorRepulsorBeam';
                if (isBeam) {
                    weapon.beamArrayExtension = parseInt(beamArrayInput.value) || 50;
                } else {
                    delete weapon.beamArrayExtension;
                }
                
                updateWeaponList();
                draw();
                status.textContent = `Updated ${weapon.name} (${weaponType})`;
            }
        });
        
        exportBtn.addEventListener('click', async () => {
            const data = {
                faction: factionSelect.value,
                shipClass: classSelect.value,
                scaleFactor: manualScaleFactor, // Include manual scale factor
                weapons: weapons
            };
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const filename = `${factionSelect.value}_${classSelect.value}_weapons.json`;
            
            // Try to use File System Access API (modern browsers) - prompts for overwrite
            if ('showSaveFilePicker' in window) {
                try {
                    const fileHandle = await window.showSaveFilePicker({
                        suggestedName: filename,
                        types: [{
                            description: 'JSON files',
                            accept: { 'application/json': ['.json'] }
                        }]
                    });
                    const writable = await fileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    status.textContent = 'Exported to JSON (includes scale factor)';
                } catch (error) {
                    // User cancelled or error occurred
                    if (error.name !== 'AbortError') {
                        console.error('Export error:', error);
                        status.textContent = 'Export cancelled or failed';
                    } else {
                        status.textContent = 'Export cancelled';
                    }
                }
            } else {
                // Fallback: Use download link (browser will handle duplicates)
                // Show confirmation dialog first
                const confirmed = confirm(`Export to ${filename}?\n\nNote: If a file with this name already exists, your browser will create a numbered version (e.g., ${filename.replace('.json', ' (1).json')}).\n\nFor overwrite confirmation, use a modern browser that supports the File System Access API.`);
                if (confirmed) {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    a.click();
                    URL.revokeObjectURL(url);
                    status.textContent = 'Exported to JSON (includes scale factor)';
                } else {
                    status.textContent = 'Export cancelled';
                }
            }
        });
        
        importBtn.addEventListener('click', () => {
            fileInput.click();
        });
        
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        if (data.faction) factionSelect.value = data.faction;
                        if (data.shipClass) classSelect.value = data.shipClass;
                        
                        // Store old scale factor before updating
                        const oldScaleFactor = manualScaleFactor;
                        
                        if (data.scaleFactor !== undefined) {
                            manualScaleFactor = parseFloat(data.scaleFactor) || 1.0;
                            loadScaleFactor();
                        }
                        
                        // Reload ship image when importing (to ensure correct size)
                        if (data.faction && data.shipClass) {
                            loadShipImage(data.faction, data.shipClass);
                        }
                        
                        if (data.weapons) {
                            weapons = data.weapons;
                            
                            // Scale weapon positions if scale factor changed
                            // Positions need to be adjusted when ship size changes
                            if (data.scaleFactor !== undefined && oldScaleFactor !== manualScaleFactor && oldScaleFactor > 0) {
                                const scaleRatio = manualScaleFactor / oldScaleFactor;
                                weapons.forEach(weapon => {
                                    if (weapon.position) {
                                        weapon.position.x *= scaleRatio;
                                        weapon.position.y *= scaleRatio;
                                    }
                                });
                            }
                            
                            selectedWeaponIndex = -1;
                            updateWeaponList();
                            
                            // Wait a moment for image to load, then redraw (positions will be correct after scaling)
                            setTimeout(() => {
                                draw();
                                status.textContent = 'Imported from JSON' + (data.scaleFactor !== undefined && oldScaleFactor !== manualScaleFactor ? ` (weapon positions scaled to match ship size)` : '');
                            }, 100);
                        }
                    } catch (error) {
                        status.textContent = 'Error importing JSON: ' + error.message;
                    }
                };
                reader.readAsText(file);
            }
        });
        
        // Image loading handlers
        loadImageBtn.addEventListener('click', () => {
            imageInput.click();
        });
        
        clearImageBtn.addEventListener('click', () => {
            shipImage = null;
            imageScale = 1.0;
            imageOffset = { x: 0, y: 0 };
            draw();
            status.textContent = 'Image cleared';
        });
        
        // Scale factor input handler
        scaleFactorInput.addEventListener('input', (e) => {
            manualScaleFactor = parseFloat(e.target.value) || 1.0;
            draw();
            status.textContent = `Scale factor: ${(manualScaleFactor * 100).toFixed(1)}%`;
        });
        
        scaleFactorInput.addEventListener('change', (e) => {
            manualScaleFactor = parseFloat(e.target.value) || 1.0;
            draw();
            status.textContent = `Scale factor set to: ${(manualScaleFactor * 100).toFixed(1)}%`;
        });
        
        // Beam array extension input handlers
        beamArrayInput.addEventListener('input', (e) => {
            if (selectedWeaponIndex >= 0 && selectedWeaponIndex < weapons.length) {
                const weapon = weapons[selectedWeaponIndex];
                if (weapon.type === 'continuousBeam' || weapon.type === 'heavyBeam') {
                    weapon.beamArrayExtension = parseInt(e.target.value) || 50;
                    draw();
                }
            }
        });
        
        beamArrayInput.addEventListener('change', (e) => {
            if (selectedWeaponIndex >= 0 && selectedWeaponIndex < weapons.length) {
                const weapon = weapons[selectedWeaponIndex];
                if (weapon.type === 'continuousBeam' || weapon.type === 'heavyBeam') {
                    weapon.beamArrayExtension = parseInt(e.target.value) || 50;
                    draw();
                    status.textContent = `Beam array extension updated: ${weapon.beamArrayExtension}`;
                }
            }
        });
        
        imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        shipImage = img;
                        // Calculate scale based on actual image length and class size requirements
                        imageScale = calculateImageScale(img, classSelect.value);
                        imageOffset = { x: 0, y: 0 };
                        // Preserve manual scale factor when loading new image
                        // (don't reset it, just recalculate imageScale)
                        draw();
                        const actualLength = measureImageLength(img);
                        status.textContent = `Image loaded: ${file.name} - Length: ${actualLength}px, Scale: ${(imageScale * 100).toFixed(1)}%, Final: ${(imageScale * manualScaleFactor * 100).toFixed(1)}%`;
                    };
                    img.onerror = () => {
                        status.textContent = 'Error loading image';
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });
        
        // Initialize
        loadDefaultWeapons();
        loadScaleFactor();
        zoomValue.textContent = '100%';
        updateMode('idle');
    </script>
</body>
</html>



